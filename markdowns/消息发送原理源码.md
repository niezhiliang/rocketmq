### 前言





### Producer端发送流程

下面是producer发送一条简单消息的代码，我们一句句来分析，看下具体做了哪些事情

```java
//初始化发送消息的线程池
DefaultMQProducer producer = new DefaultMQProducer("test-group"); //1
producer.setNamesrvAddr("localhost:9876");
producer.start();//2
//消息发送
producer.send(new Message("testMsg","hello broker! I am producer".getBytes()));//3
TimeUnit.SECONDS.sleep(3);
producer.shutdown();
```

我们先看第一句代码`new DefaultMQProducer("test-group")`

- 设置producer的namespace和group
- 创建消息发送的线程池

再看第二句代码`producer.start()`

- 验证producer的group是否符合规范

  - 不能为空
  - 字符长度不能超过255
  - 命名需要符合这个正则`^[%|a-zA-Z0-9_-]+$`

- 修改producer实例的名称，如果`groupName`不等于`CLIENT_INNER_PRODUCER`的都会呗改成当前进程ID

- 实例化mqClient  --> MQClientManager的ConcurrentMap<String/* clientId */, MQClientInstance> factoryTable

  - 如果缓存中存在该实例，从缓存中取，不存在创建后放入再返回

- 将producer注册到MQClientInstance的ConcurrentMap<String/* group */, MQProducerInner> producerTable中

- 将自动创建topic的TBW102放到topicPublishInfoTable缓存中

  - 如果设置了`isAutoCreateTopicEnabl=true`假设topic不存在，会自动创建

- 启动mqClient 

  - 如果nameserver地址为空，会去`http:// + WS_DOMAIN_NAME + ":8080/rocketmq/" + WS_DOMAIN_SUBGROUP`获取，WS_DOMAIN_NAME由配置参数rocketmq.namesrv.domain设置，WS_DOMAIN_SUBG由配置参数rocketmq.namesrv.domain.subgroup设置
  - 开启服务的请求和响应通道
  - 开启一些定时任务
    - 每隔30s向nameserver拉取最新的broker和topic的路由信息
    - 每隔30s向broker发送心跳包
    - 每隔5s持久化consumer的offset
    - 每隔60s动态调整线程池数量(代码暂时被注释了)
  - 启动拉取消息的服务
  - 启动消息队列重新负载的服务（默认为平均算法）后期会有一篇专门讲这个consumer的负载均衡策略
  - 启动producer消息推送服务，参数传的false，会调到`DefaultMQProducerImpl#start()方法`，这个方法和`producer.start()`这句代码区别就是当前这个start传的是false,不会启动mqClient，其余都一样。

- 将producer的服务设置为RUNNING状态

- 向所有的broker发送心跳包

  - 给broker发送心跳包

    - 从MQClientInstance#brokerAddrTable取出所有broker（在发送的时候才会将broker放入该缓存中），向所有master发送心跳包

      > HeartbeatData [clientID=10.1.180.112@7088, producerDataSet=[ProducerData [groupName=CLIENT_INNER_PRODUCER], ProducerData [groupName=test-group]], consumerDataSet=[]] 

  - 给filter发送过滤类

- 定时清理过期请求



```
public void start() throws MQClientException {
	//设置producerGroup
    this.setProducerGroup(withNamespace(this.producerGroup));
    //producer启动
    this.defaultMQProducerImpl.start();
    if (null != traceDispatcher) {
        try {
            traceDispatcher.start(this.getNamesrvAddr(), this.getAccessChannel());
        } catch (MQClientException e) {
            log.warn("trace dispatcher start failed ", e);
        }
    }
}
```

```java
public void start(final boolean startFactory) throws MQClientException {
    switch (this.serviceState) {
        case CREATE_JUST:
            this.serviceState = ServiceState.START_FAILED;
                //验证group不能为空 字符长度最多255 是否符合给定的正则条件"^[%|a-zA-Z0-9_-]+$"
                // 不能为默认的组DEFAULT_PRODUCER
            this.checkConfig();
			//
            if(!this.defaultMQProducer.getProducerGroup().equals(MixAll                                                                 .CLIENT_INNER_PRODUCER_GROUP)) {
                this.defaultMQProducer.changeInstanceNameToPID();
            }
            //实例化mqClient
            this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQProducer, rpcHook);

            boolean registerOK = mQClientFactory.registerProducer(this.defaultMQProducer.getProducerGroup(), this);
            if (!registerOK) {
                this.serviceState = ServiceState.CREATE_JUST;
                throw new MQClientException("The producer group[" + this.defaultMQProducer.getProducerGroup()
                    + "] has been created before, specify another name please." + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),
                    null);
            }

            this.topicPublishInfoTable.put(this.defaultMQProducer.getCreateTopicKey(), new TopicPublishInfo());

            if (startFactory) {
                mQClientFactory.start();
            }

            log.info("the producer [{}] start OK. sendMessageWithVIPChannel={}", this.defaultMQProducer.getProducerGroup(),
                this.defaultMQProducer.isSendMessageWithVIPChannel());
            this.serviceState = ServiceState.RUNNING;
            break;
        case RUNNING:
        case START_FAILED:
        case SHUTDOWN_ALREADY:
            throw new MQClientException("The producer service state not OK, maybe started once, "
                + this.serviceState
                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),
                null);
        default:
            break;
    }
```

我们再看第三句代码producer.send